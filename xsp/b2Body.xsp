%{

#include <Box2D/Box2D.h>
#include <helper.h>

%}

%module{Box2D};

%name{Box2D::b2Body} class b2Body
{

float32 GetAngle();

void SetAngularVelocity( float32 omega );

float32 GetAngularVelocity();

void ApplyTorque( float32 torque );

void ApplyAngularImpulse( float32 impulse );

float32 GetMass();

float32 GetInertia();

void ResetMassData();

float32 GetLinearDamping();

void SetLinearDamping( float32 linearDamping );

float32 GetAngularDamping();

void SetAngularDamping( float32 angularDamping );

float32 GetGravityScale();

void SetGravityScale( float32 scale );

void SetBullet( bool flag );

bool IsBullet();

void SetSleepingAllowed( bool flag );

bool IsSleepingAllowed();

void SetAwake( bool flag );

bool IsAwake();

void SetActive( bool flag );

bool IsActive();

void SetFixedRotation( bool flag );

bool IsFixedRotation();

%{

BOOT:
{
	HV* stash = gv_stashpv( "Box2D", TRUE );

	/* enum b2BodyType */
	constsub_exporting( stash, "b2_staticBody",    newSViv((IV) b2_staticBody   ), "body" );
	constsub_exporting( stash, "b2_kinematicBody", newSViv((IV) b2_kinematicBody), "body" );
	constsub_exporting( stash, "b2_dynamicBody",   newSViv((IV) b2_dynamicBody  ), "body" );
}

void*
b2Body::CreateFixture( ... )
	PREINIT:
		const char* CLASS = "Box2D::b2Fixture";
	CODE:
		if( items == 2 )
			RETVAL = THIS->CreateFixture( (const b2FixtureDef*) stack_to_object( ST(1) ) );
		else if( items == 3 )
			RETVAL = THIS->CreateFixture( (const b2Shape*) stack_to_object( ST(1) ), SvNV( ST(2) ) );
		else
			croak_xs_usage(cv,  "THIS, (def)||(shape, density)");
	OUTPUT:
		RETVAL

void
b2Body::DestroyFixture( fixture )
	SV* fixture
	CODE:
		THIS->DestroyFixture( (b2Fixture*) stack_to_object(fixture) );
		*(SvRV(fixture)) = PL_sv_undef;

void
b2Body::SetTransform( position, angle )
	b2Vec2* position
	float32 angle
	CODE:
		THIS->SetTransform( *position, angle );


void*
b2Body::GetTransform( )
	PREINIT:
		const char* CLASS = "Box2D::b2Transform";
	CODE:
		RETVAL = (b2Transform*) &(THIS->GetTransform());
	OUTPUT:
		RETVAL

void*
b2Body::GetPosition()
	PREINIT:
		const char* CLASS = "Box2D::b2Vec2";
	CODE:
		RETVAL = (b2Vec2*) &(THIS->GetPosition());
	OUTPUT:
		RETVAL

void*
b2Body::GetWorldCenter()
	PREINIT:
		const char* CLASS = "Box2D::b2Vec2";
	CODE:
		RETVAL = (b2Vec2*) &(THIS->GetWorldCenter());
	OUTPUT:
		RETVAL

void*
b2Body::GetLocalCenter()
	PREINIT:
		const char* CLASS = "Box2D::b2Vec2";
	CODE:
		RETVAL = (b2Vec2*) &(THIS->GetLocalCenter());
	OUTPUT:
		RETVAL

void
b2Body::SetLinearVelocity( v )
	b2Vec2* v
	CODE:
		THIS->SetLinearVelocity( *v );

void*
b2Body::GetLinearVelocity()
	PREINIT:
		const char* CLASS = "Box2D::b2Vec2";
	CODE:
		RETVAL = new b2Vec2(THIS->GetLinearVelocity());
	OUTPUT:
		RETVAL

void
b2Body::ApplyForce( force, point )
	b2Vec2* force
	b2Vec2* point
	CODE:
		THIS->ApplyForce( *force, *point );

void
b2Body::ApplyForceToCenter( force )
	b2Vec2* force
	CODE:
		THIS->ApplyForceToCenter( *force );

void
b2Body::ApplyLinearImpulse( impulse, point )
	b2Vec2* impulse
	b2Vec2* point
	CODE:
		THIS->ApplyLinearImpulse( *impulse, *point );

void
b2Body::GetMassData( data )
	b2MassData* data
	CODE:
		THIS->GetMassData( data );

void
b2Body::SetMassData( data )
	b2MassData* data
	CODE:
		THIS->SetMassData( data );

void*
b2Body::GetWorldPoint( localPoint )
	b2Vec2* localPoint
	PREINIT:
		const char* CLASS = "Box2D::b2Vec2";
	CODE:
		RETVAL =  new b2Vec2(THIS->GetWorldPoint( *localPoint ));
	OUTPUT:
		RETVAL

void*
b2Body::GetWorldVector( localVector )
	b2Vec2* localVector
	PREINIT:
		const char* CLASS = "Box2D::b2Vec2";
	CODE:
		RETVAL = new b2Vec2(THIS->GetWorldVector( *localVector ));
	OUTPUT:
		RETVAL

void*
b2Body::GetLocalPoint( worldPoint )
	b2Vec2* worldPoint
	PREINIT:
		const char* CLASS = "Box2D::b2Vec2";
	CODE:
		RETVAL = new b2Vec2(THIS->GetLocalPoint( *worldPoint ));
	OUTPUT:
		RETVAL

void*
b2Body::GetLocalVector( worldVector )
	b2Vec2* worldVector
	PREINIT:
		const char* CLASS = "Box2D::b2Vec2";
	CODE:
		RETVAL = new b2Vec2(THIS->GetLocalVector( *worldVector ));
	OUTPUT:
		RETVAL

void*
b2Body::GetLinearVelocityFromWorldPoint( worldPoint )
	b2Vec2* worldPoint
	PREINIT:
		const char* CLASS = "Box2D::b2Vec2";
	CODE:
		RETVAL = new b2Vec2(THIS->GetLinearVelocityFromWorldPoint( *worldPoint ));
	OUTPUT:
		RETVAL

void*
b2Body::GetLinearVelocityFromLocalPoint( localPoint )
	b2Vec2* localPoint
	PREINIT:
		const char* CLASS = "Box2D::b2Vec2";
	CODE:
		RETVAL = new b2Vec2(THIS->GetLinearVelocityFromLocalPoint( *localPoint ));
	OUTPUT:
		RETVAL

void
b2Body::SetType(type)
	int type
	CODE:
		THIS->SetType( (b2BodyType)type );

int
b2Body::GetType()
	CODE:
		RETVAL = (int) THIS->GetType();
	OUTPUT:
		RETVAL

void*
b2Body::GetFixtureList()
	PREINIT:
		const char* CLASS = "Box2D::b2Fixture";
	CODE:
		RETVAL = THIS->GetFixtureList();
	OUTPUT:
		RETVAL

void*
b2Body::GetJointList()
	PREINIT:
		const char* CLASS = "Box2D::b2JointEdge";
	CODE:
		RETVAL = THIS->GetJointList();
	OUTPUT:
		RETVAL

void*
b2Body::GetContactList()
	PREINIT:
		const char* CLASS = "Box2D::b2ContactEdge";
	CODE:
		RETVAL = THIS->GetContactList();
	OUTPUT:
		RETVAL

void*
b2Body::GetNext()
	PREINIT:
		const char* CLASS = "Box2D::b2Body";
	CODE:
		RETVAL = THIS->GetNext();
	OUTPUT:
		RETVAL

void
b2Body::GetUserData()
	PPCODE:
		void* data = THIS->GetUserData();
		if ( data == NULL )
			XSRETURN_UNDEF;
		ST(0) = (SV*) data;
		XSRETURN(1);

void
b2Body::SetUserData( data )
	SV* data
	CODE:
		THIS->SetUserData( (void*) newSVsv( data ) );

void*
b2Body::GetWorld()
	PREINIT:
		const char* CLASS = "Box2D::b2World";
	CODE:
		RETVAL = THIS->GetWorld();
	OUTPUT:
		RETVAL

void
b2Body::Dump()
	CODE:
		THIS->Dump();

%}

};

