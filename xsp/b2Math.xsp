%{

#include <Box2D/Box2D.h>

%}

%module{Box2D};
%package{Box2D};

%{

bool
b2IsValid( x )
	float32 x
	CODE:
		RETVAL = b2IsValid(x);
	OUTPUT:
		RETVAL

float32
b2InvSqrt( x )
	float32 x
	CODE:
		RETVAL = b2InvSqrt(x);
	OUTPUT:
		RETVAL

float32
b2Sqrt( x )
	float32 x
	CODE:
		RETVAL = b2Sqrt(x);
	OUTPUT:
		RETVAL

float32
b2Atan2( y, x )
	float32 y
	float32 x
	CODE:
		RETVAL = b2Atan2( y, x );
	OUTPUT:
		RETVAL
		
void*
b2Vec2_zero()
	PREINIT:
		const char* CLASS = "Box2D::b2Vec2";
	CODE:
		RETVAL = new b2Vec2(b2Vec2_zero);
	OUTPUT:
		RETVAL

float32
b2Dot( a, b )
	SV* a
	SV* b
	CODE:
		if(sv_isobject(a)) {
			if(sv_derived_from(a, "Box2D::b2Vec2")) {
				if(sv_isobject(b) && sv_derived_from(b, "Box2D::b2Vec2")) {
					RETVAL = b2Dot( *(b2Vec2*)SvIV(SvRV(a)), *(b2Vec2*)SvIV(SvRV(b)) );
				}
				else XSRETURN_UNDEF;
			}
			else if(sv_derived_from(a, "Box2D::b2Vec3")) {
				if(sv_isobject(b) && sv_derived_from(b, "Box2D::b2Vec3")) {
					RETVAL = b2Dot( *(b2Vec3*)SvIV(SvRV(a)), *(b2Vec3*)SvIV(SvRV(b)) );
				}
				else XSRETURN_UNDEF;
			}
			else XSRETURN_UNDEF;
		}
		else XSRETURN_UNDEF;
	OUTPUT:
		RETVAL

void*
b2Cross( x, y )
	SV* x
	SV* y
	PREINIT:
		const char* CLASS;
	CODE:
		if(sv_isobject(x) && sv_derived_from(x, "Box2D::b2Vec2")) {
			if(sv_isobject(y) && sv_derived_from(y, "Box2D::b2Vec2")) {
				XSRETURN_NV((NV)b2Cross(*(b2Vec2*)SvIV(SvRV(x)), *(b2Vec2*)SvIV(SvRV(y))));
			}
			else {
				RETVAL = new b2Vec2(b2Cross(*(b2Vec2*)SvIV(SvRV(x)), (float32)SvNV(y)));
				CLASS = "Box2D::b2Vec2";
			}
		}
		else if(sv_isobject(y)) {
			if(sv_derived_from(y, "Box2D::b2Vec2")) {
				RETVAL = new b2Vec2(b2Cross((float32)SvNV(x), *(b2Vec2*)SvIV(SvRV(y))));
				CLASS = "Box2D::b2Vec2";
			}
			else if(sv_isobject(x) && sv_derived_from(x, "Box2D::b2Vec3") && sv_derived_from(y, "Box2D::b2Vec3")) {
				RETVAL = new b2Vec3(b2Cross(*(b2Vec3*)SvIV(SvRV(x)), *(b2Vec3*)SvIV(SvRV(y))));
				CLASS = "Box2D::b2Vec3";
			}
			else XSRETURN_UNDEF;
		}
		else XSRETURN_UNDEF;
	OUTPUT:
		RETVAL

void*
b2Mul( x, y )
	SV* x
	SV* y
	PREINIT:
		const char* CLASS;
	CODE:
		if(!sv_isobject(x) || !sv_isobject(y))
			XSRETURN_UNDEF;

		if(sv_derived_from(y, "Box2D::b2Vec2")) {
			if(sv_derived_from(x, "Box2D::b2Mat22"))
				RETVAL = new b2Vec2(b2Mul( *(b2Mat22*)SvIV(SvRV(x)), *(b2Vec2*)SvIV(SvRV(y)) ));
				
			else if(sv_derived_from(x, "Box2D::b2Rot"))
				RETVAL = new b2Vec2(b2Mul( *(b2Rot*)SvIV(SvRV(x)), *(b2Vec2*)SvIV(SvRV(y)) ));
				
			else if(sv_derived_from(x, "Box2D::b2Transform"))
				RETVAL = new b2Vec2(b2Mul( *(b2Transform*)SvIV(SvRV(x)), *(b2Vec2*)SvIV(SvRV(y)) ));
				
			else
				XSRETURN_UNDEF;
				
			CLASS = "Box2D::b2Vec2";
		}
		else if(sv_derived_from(x, "Box2D::b2Mat22") && sv_derived_from(y, "Box2D::b2Mat22")) {
			RETVAL = new b2Mat22(b2Mul( *(b2Mat22*)SvIV(SvRV(x)), *(b2Mat22*)SvIV(SvRV(y)) ));
			CLASS = "Box2D::b2Mat22";
		}
		else if(sv_derived_from(x, "Box2D::b2Mat33") && sv_derived_from(y, "Box2D::b2Vec3")) {
			RETVAL = new b2Vec3(b2Mul( *(b2Mat33*)SvIV(SvRV(x)), *(b2Vec3*)SvIV(SvRV(y)) ));
			CLASS = "Box2D::b2Vec3";
		}
		else if(sv_derived_from(x, "Box2D::b2Rot") && sv_derived_from(y, "Box2D::b2Rot")) {
			RETVAL = new b2Rot(b2Mul( *(b2Rot*)SvIV(SvRV(x)), *(b2Rot*)SvIV(SvRV(y)) ));
			CLASS = "Box2D::b2Rot";
		}
		else if(sv_derived_from(x, "Box2D::b2Transform") && sv_derived_from(y, "Box2D::b2Transform")) {
			RETVAL = new b2Transform(b2Mul( *(b2Transform*)SvIV(SvRV(x)), *(b2Transform*)SvIV(SvRV(y)) ));
			CLASS = "Box2D::b2Transform";
		}
		else
			XSRETURN_UNDEF;
	OUTPUT:
		RETVAL

void*
b2MulT( x, y )
	SV* x
	SV* y
	PREINIT:
		const char* CLASS;
	CODE:
		if(!sv_isobject(x) || !sv_isobject(y))
			XSRETURN_UNDEF;

		if(sv_derived_from(y, "Box2D::b2Vec2")) {
			if(sv_derived_from(x, "Box2D::b2Mat22"))
				RETVAL = new b2Vec2(b2MulT( *(b2Mat22*)SvIV(SvRV(x)), *(b2Vec2*)SvIV(SvRV(y)) ));
				
			else if(sv_derived_from(x, "Box2D::b2Rot"))
				RETVAL = new b2Vec2(b2MulT( *(b2Rot*)SvIV(SvRV(x)), *(b2Vec2*)SvIV(SvRV(y)) ));
				
			else if(sv_derived_from(x, "Box2D::b2Transform"))
				RETVAL = new b2Vec2(b2MulT( *(b2Transform*)SvIV(SvRV(x)), *(b2Vec2*)SvIV(SvRV(y)) ));
				
			else
				XSRETURN_UNDEF;
				
			CLASS = "Box2D::b2Vec2";
		}
		else if(sv_derived_from(x, "Box2D::b2Mat22") && sv_derived_from(y, "Box2D::b2Mat22")) {
			RETVAL = new b2Mat22(b2MulT( *(b2Mat22*)SvIV(SvRV(x)), *(b2Mat22*)SvIV(SvRV(y)) ));
			CLASS = "Box2D::b2Mat22";
		}
		else if(sv_derived_from(x, "Box2D::b2Rot") && sv_derived_from(y, "Box2D::b2Rot")) {
			RETVAL = new b2Rot(b2MulT( *(b2Rot*)SvIV(SvRV(x)), *(b2Rot*)SvIV(SvRV(y)) ));
			CLASS = "Box2D::b2Rot";
		}
		else if(sv_derived_from(x, "Box2D::b2Transform") && sv_derived_from(y, "Box2D::b2Transform")) {
			RETVAL = new b2Transform(b2MulT( *(b2Transform*)SvIV(SvRV(x)), *(b2Transform*)SvIV(SvRV(y)) ));
			CLASS = "Box2D::b2Transform";
		}
		else
			XSRETURN_UNDEF;
	OUTPUT:
		RETVAL

void*
_vec2_add( a, b )
	b2Vec2* a
	b2Vec2* b
	PREINIT:
		const char* CLASS = "Box2D::b2Vec2";
	CODE:
		RETVAL = new b2Vec2( *a + *b );
	OUTPUT:
		RETVAL

void*
_vec2_subtract( a, b )
	b2Vec2* a
	b2Vec2* b
	PREINIT:
		const char* CLASS = "Box2D::b2Vec2";
	CODE:
		RETVAL = new b2Vec2( *a - *b );
	OUTPUT:
		RETVAL

void*
_vec2_multiply( s, a )
	float32 s
	b2Vec2* a
	PREINIT:
		const char* CLASS = "Box2D::b2Vec2";
	CODE:
		RETVAL = new b2Vec2( s * *a );
	OUTPUT:
		RETVAL

bool
_vec2_equal( a, b )
	b2Vec2* a
	b2Vec2* b
	CODE:
		RETVAL = *a == *b;
	OUTPUT:
		RETVAL

float32
b2Distance( a, b )
	b2Vec2* a
	b2Vec2* b
	CODE:
		RETVAL = b2Distance( *a, *b );
	OUTPUT:
		RETVAL

float32
b2DistanceSquared( a, b )
	b2Vec2* a
	b2Vec2* b
	CODE:
		RETVAL = b2DistanceSquared( *a, *b );
	OUTPUT:
		RETVAL

void*
_vec3_multiply( s, a )
	float32 s
	b2Vec3* a
	PREINIT:
		const char* CLASS = "Box2D::b2Vec3";
	CODE:
		RETVAL = new b2Vec3( s * *a );
	OUTPUT:
		RETVAL

void*
_vec3_add( a, b )
	b2Vec3* a
	b2Vec3* b
	PREINIT:
		const char* CLASS = "Box2D::b2Vec3";
	CODE:
		RETVAL = new b2Vec3( *a + *b );
	OUTPUT:
		RETVAL

void*
_vec3_subtract( a, b )
	b2Vec3* a
	b2Vec3* b
	PREINIT:
		const char* CLASS = "Box2D::b2Vec3";
	CODE:
		RETVAL = new b2Vec3( *a - *b );
	OUTPUT:
		RETVAL

void*
_mat22_add( A, B )
	b2Mat22* A
	b2Mat22* B
	PREINIT:
		const char* CLASS = "Box2D::b2Mat22";
	CODE:
		RETVAL = new b2Mat22( *A + *B );
	OUTPUT:
		RETVAL

void*
b2Mul22( A, v )
	b2Mat33* A
	b2Vec2* v
	PREINIT:
		const char* CLASS = "Box2D::b2Vec2";
	CODE:
		RETVAL = new b2Vec2( b2Mul22( *A, *v ) );
	OUTPUT:
		RETVAL
		
void*
b2Abs( x )
	SV* x
	PREINIT:
		const char* CLASS;
	CODE:
		if(sv_isobject(x)) {
			if(sv_derived_from(x, "Box2D::b2Vec2")) {
				RETVAL = new b2Vec2(b2Abs(*(b2Vec2*)SvIV(SvRV(x))));
				CLASS = "Box2D::b2Vec2";
			}
			else if(sv_derived_from(x, "Box2D::b2Mat22")) {
				RETVAL = new b2Mat22(b2Abs(*(b2Mat22*)SvIV(SvRV(x))));
				CLASS = "Box2D::b2Mat22";
			}
			else
				XSRETURN_NV(b2Abs(SvNV(x)));
		}
		else
			XSRETURN_NV(b2Abs(SvNV(x)));
	OUTPUT:
		RETVAL

void*
b2Min( a, b )
	SV* a
	SV* b
	PREINIT:
		const char* CLASS = "Box2D::b2Vec2";
	CODE:
		if(sv_isobject(a) && sv_derived_from(a, "Box2D::b2Vec2")
		&& sv_isobject(b) && sv_derived_from(b, "Box2D::b2Vec2")) {
			RETVAL = new b2Vec2(b2Min(*(b2Vec2*)SvIV(SvRV(a)), *(b2Vec2*)SvIV(SvRV(b))));
		}
		else
			XSRETURN_NV(b2Min(SvNV(a), SvNV(b)));
	OUTPUT:
		RETVAL

void*
b2Max( a, b )
	SV* a
	SV* b
	PREINIT:
		const char* CLASS = "Box2D::b2Vec2";
	CODE:
		if(sv_isobject(a) && sv_derived_from(a, "Box2D::b2Vec2")
		&& sv_isobject(b) && sv_derived_from(b, "Box2D::b2Vec2")) {
			RETVAL = new b2Vec2(b2Max(*(b2Vec2*)SvIV(SvRV(a)), *(b2Vec2*)SvIV(SvRV(b))));
		}
		else
			XSRETURN_NV(b2Max(SvNV(a), SvNV(b)));
	OUTPUT:
		RETVAL

void*
b2Clamp( a, low, high )
	SV* a
	SV* low
	SV* high
	PREINIT:
		const char* CLASS = "Box2D::b2Vec2";
	CODE:
		if(sv_isobject(a   ) && sv_derived_from(a,    "Box2D::b2Vec2")
		&& sv_isobject(low ) && sv_derived_from(low,  "Box2D::b2Vec2")
		&& sv_isobject(high) && sv_derived_from(high, "Box2D::b2Vec2")) {
			RETVAL = new b2Vec2(b2Clamp(*(b2Vec2*)SvIV(SvRV(a)), *(b2Vec2*)SvIV(SvRV(low)), *(b2Vec2*)SvIV(SvRV(high))));
		}
		else
			XSRETURN_NV(b2Clamp(SvNV(a), SvNV(low), SvNV(high)));
	OUTPUT:
		RETVAL

void
b2Swap( a, b )
	SV* a
	SV* b
	CODE:
		b2Swap(*a, *b);

uint32
b2NextPowerOfTwo( x )
	uint32 x
	CODE:
		RETVAL = b2NextPowerOfTwo(x);
	OUTPUT:
		RETVAL

bool
b2IsPowerOfTwo( x )
	uint32 x
	CODE:
		RETVAL = b2IsPowerOfTwo(x);
	OUTPUT:
		RETVAL

%}
