%{

#include <Box2D/Box2D.h>
#include <Box2D/Collision/Shapes/b2Shape.h>

%}

%module{Box2D};

%name{Box2D::b2Shape} class b2Shape
{

int32 GetChildCount();

%{

BOOT:
{
	HV* stash = gv_stashpv( "Box2D::b2Shape", TRUE );

	/* enum b2Shape::Type */
	constsub_exporting( stash, "e_circle",    newSViv((IV) b2Shape::e_circle   ), "shape" );
	constsub_exporting( stash, "e_edge",      newSViv((IV) b2Shape::e_edge     ), "shape" );
	constsub_exporting( stash, "e_polygon",   newSViv((IV) b2Shape::e_polygon  ), "shape" );
	constsub_exporting( stash, "e_chain",     newSViv((IV) b2Shape::e_chain    ), "shape" );
	constsub_exporting( stash, "e_typeCount", newSViv((IV) b2Shape::e_typeCount), "shape" );
}

void*
b2Shape::Clone( allocator )
	b2BlockAllocator* allocator
	PREINIT:
		const char* CLASS = "Box2D::b2Shape";
	CODE:
		RETVAL = THIS->Clone( allocator );
	OUTPUT:
		RETVAL

int
b2Shape::GetType( )
	CODE:
		RETVAL = (int)THIS->GetType();
	OUTPUT:
		RETVAL

bool
b2Shape::TestPoint( xf, p )
	b2Transform* xf
	b2Vec2* p
	CODE:
		RETVAL = THIS->TestPoint( *xf, *p );
	OUTPUT:
		RETVAL

bool
b2Shape::RayCast( output, input, transform, childIndex )
	b2RayCastOutput* output
	b2RayCastInput* input
	b2Transform* transform
	int32 childIndex
	CODE:
		RETVAL = THIS->RayCast( output, *input, *transform, childIndex );
	OUTPUT:
		RETVAL

void
b2Shape::ComputeAABB( aabb, xf, childIndex )
	b2AABB* aabb
	b2Transform* xf
	int32 childIndex
	CODE:
		THIS->ComputeAABB( aabb, *xf, childIndex );

void
b2Shape::ComputeMass( massData, density )
	b2MassData* massData
	float32 density
	CODE:
		THIS->ComputeMass( massData, density );

int
b2Shape::m_type( ... )
	CODE:
		if ( items > 1 )
		{
			THIS->m_type = (b2Shape::Type)SvIV( ST(1) );
		}
		RETVAL = (int)THIS->m_type;
	OUTPUT:
		RETVAL

float32
b2Shape::m_radius( ... )
	CODE:
		if ( items > 1 )
		{
			THIS->m_radius = (float32)SvNV( ST(1) );
		}
		RETVAL = THIS->m_radius;
	OUTPUT:
		RETVAL

%}

};
